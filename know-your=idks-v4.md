# know-your=idks-v4

**Source:** know-your=idks-v4.mp4

## Transcript

 Welcome to lesson 3. Your last beginner principled AI coding lesson. Over lesson 1 and 2, you've learned the basics and learned the essential commands to give your AI coding assistant the context it needs to run multi-file edits. Now it's time to learn how to craft the perfect prompt. As you may have noticed, not all prompts get the job done. In this lesson, you're going to learn specific keywords and prompt phrases that will generate the exact results you're looking for. That means you'll spend less time reviewing your AI coding assistant's outputs and more time shipping valuable features for your projects and your work. Lesson by lesson, you're unlocking massive productivity multipliers by using AI coding tools the right way. Crafting great AI coding prompts is about knowing how your AI coding assistant and the underlying large language model will respond to your prompt. You want to be consistently hitting the big three bulls eye, the intersection between your prompt, your context, and your model. They're going to be many engineers using AI coding tools. There already are. But most engineers will be writing ineffective, nondescript, error-prone prompts that they'll have to fix and iterate on. This lesson is going to help you bypass all of these issues and save a ton of time. Crafting the perfect prompt begins with understanding the principle behind this lesson. Let me introduce you to IDKs, also known as information dense keywords. IDKs are a result of the simple train of logic. Prumps are made up of individual keywords. Some of these keywords contain more information that carry more meaning and more action with them. All keywords are not equal to each other. Therefore we should select the highest performing keywords based on their information density to create the best prompts. Simple enough, right? I'm basically calling out the fact that if you want to communicate something to an LLM or to a person, there are better and worse ways to communicate. It's an obvious but important point to make. So the idea behind information dense keywords is to find and use the most valuable information rich words that best communicates what you want done to your AI coding assistant. The principle for this lesson, use information dense keywords. It's as simple as that. This is no different than if you're trying to convince, teach, discuss, or communicate something with a friend, family, or coworker. Some words are more impactful than others. It's the same with your AI coding assistant and your language models. Now naturally, you're probably thinking what are these keywords? Well, there are quite a few of them and in this lesson, we're going to go over the most impactful ones and we're going to compose these keywords by building repeatable prompt phrases. These prompt phrases will give you reliable, repeatable patterns for generating great AI coding prompts. Last I've been and see the results that information, dense keywords, and prompt phrases can have on your ability to generate lots of code quickly and accurately with your AI coding assistant. Let's open up the terminal and clone in the lesson three repository. As always, the link will be in your loot box below. If I LS, you can see our previous two lessons. All around Git clone, paste in the URL. Now if I run LS, I can now see our third lesson. Let's CD into our new directory and open your favorite code editor. I'll use VS code, so I'll type code dot. Go ahead and copy your dot environment variable file from your lesson to code base into the directory or open up the readme and follow the second setup instruction here. Copy your dot m sample into the dot m and set up your open AI key and or your anthropic API key use, whichever you prefer. They're both going to provide a great out of the box model for your AI coding. I'll go ahead and grab my dot environment variable now. Once you have your dot end file setup, open up a terminal and install our dependencies. I'm going to run UV sync and then we can run UV run main transcript dot txt. This will kick off our previous version and if we go into source main, you can see we're right where we left off from our second AI coding lesson. We're going to build off our lesson to repository and add some additional features to our transcript analysis application. Just like in lesson two, let's start by outlining the changes we're going to make to our transcription app. Planning out work is an important pattern we're going to full utilize in upcoming lessons. It's also a great engineering practice to plan your work before you start coding. Right now our transcription application reads in a text file of a YouTube video or presentation, counts the frequencies of words and then uses open AI to generate a summary, determine sentiment and extract keywords. We can see the output of our run here. We have a list of words with their frequencies and we have a transcription analysis with a quick summary bullet point highlights, sentiment analysis and keywords. We set this up in lesson one and two and in this lesson, we're going to improve it by making a few changes. We're going to add an output flag so we can output our analysis in JSON, mark down or plain text files. This gets us out of viewing our results from only the CLI. Then we'll update our application to output a bar chart for our word frequencies. This will make it easier to digest our word frequencies and understand the most common words. Right now we're using this simple hashtag pattern. This is a great start but we're going to improve it. These features will move our CLI transcription app toward a more useful production-ready tool. Our main focus is on the AI coding involved in getting these features built, not the features themselves. Now, let's start by listing the most important, most valuable, most common information dense keywords. We first have create, update, delete. Then we have add, remove, move, replace, save, mirror. Then there is var, function, class, type, file, default. These keywords are distinct even though they may have equal alternatives, their clear, concise, and have a direct action or meaning associated with them. Right away it's important to call out a few things. These keywords have variants. For instance, the update keyword can be replaced with change. Create can be replaced by build. Delete can be replaced by remove. But you can see how the information, density of the idea of creating is lost. The further you travel away from the word, for instance, create, write, build, make, code. Every one of these steps, although they are all variants and will likely all work, you don't want to drift too far away from what you're actually trying to do. These information dense keywords are important because they capture the most common operations for AI coding. The first three are the most important. Create, update, and delete. In each programming language, using a specific var or function or type appropriate keyword usually results in more accurate prompts. For instance, in TypeScript, you would identify a function with the function keyword. As we have here, and as you'll see in a moment, we use the deaf keyword. Files are another example. We use file extensions to denote the file information dense keyword. In lesson two, we ran a prompt like createargaparse.py. The .py is what makes this string an idk and information dense keyword. By adding .py to something, we make it an information dense keyword because the underlying language model knows that .py is one of hundreds of file extensions. Last thing to note, this is a limited list of the essential idk's you will and likely already have run into. There are more. Take note of the words and the strings you keep writing in your prompts that tend to work. They're likely idk's. Now, instead of trying to cherry pick, prompts to show off idk's, let's write real prompts to build up these features. We'll start by adding an output flag to our transcription analysis code base. Let's go ahead and open the terminal, clear out our output, and boot up aader. We're going to hit slash add, main, use aader's autocomplete to grab the main file and then hit space to add another file. I'm also going to add our data types. Why do we want data types? Let's go ahead and open our data types file. We have our transcript analysis here and we're going to be working with that in this prompt. To kick things off, we'll execute an a iCoding prompt to generate that new output format using several idk's. From now on, I'm going to capitalize the keywords where it makes sense. So it's clear in our a iCoding prompts where the information dense keywords are. Let's hop back to main, open up our code, and just to quickly review. We're opening up our transcription file. We're counting the word frequencies. We're sorting them and they were printing and then we're running our open a iCode to run our sentiment analysis. If we open to this function, you can see what that looks like here. And then we're just printing it out. So let's go ahead and make our modifications so that we can output files and different formats. We'll do it with this prompt, create, output format, dot p y, colon. So we're going to create a new file here, create, death, format, as, stir. And then we're going to pass in transcript and then colon, transcript analysis. You can see, aider has the context of our data types. So it's giving us some nice auto complete here. We're going to highlight our transcript analysis type. And now we're going to specify the return type and Python. So we're going to say, dash greater than string. So we want to get strings back from this function. Let's go ahead and continue and then we'll reflect on this prompt in a moment. I'm going to use a comma here to denote a list. And then I'll also type format as JSON, dot, dot, dot, format, as markdown, dot, dot, dot, then update main dot p y, right? Because after we create this file that formats are transcript analysis, we now need to update our main file to use that new code. So now I'm going to explicitly say update main colon, add all caps, acl i arg for file, output format, default text, right? So we're saying, I'll use a comma here just to add another detail and then I'll say save output to file with proper extension. Okay. This is our a coding prompt. Let's fire it off, right? Let's finally get some a coding and let's see the results. Here's we can see Adder walking through these changes for us. Wonderful. This is our new file. We have the imports. We have the flag and we have the output format. Wonderful. So asking us if we want to create this new output format file, we're going to go ahead and say yes, of course. And now Adder has made those changes for us. So you can see we also have that added to our context. We can go ahead and look at that new file. So we have every function just as we asked, format s string, format s json, format as markdown. If we hop back to main, we can see we now have that new parser, are interestingly here. We forgot to add the context of our arg parse file, right? Which is where we're actually doing our argument parsing. So we can go ahead and fix that. Let's first continue reviewing our code. We can see here at the bottom, we're now looking at a response formats and based on the response format, we're now getting that concrete output file type. So we're running our format s string, format s json, format as markdown. And then our file extension is getting passed to our output file and finally created. Let's go ahead and get this parser code moved into the arg parse file by adding this file to our context. So I'll just say slash add arg parse. You can see aiders autocomplete kicking in there. We'll accept that. So let's go ahead and write that prompt to move our output format into our arg parse file. So to do that, we'll just write move output format, CLI arg into arg parse dot p y. Okay. So we'll kick that off. This is going to go ahead and move that code over. So if you move over to arg parse, we can see that moved properly. Let's go ahead and execute our code. Let's go ahead, open up a new terminal in VS code. We can use command, ship j and let's run this code. So I'll type UV run main transcript dot txt. Let's go ahead and use our new flag. So I'll type dash dash output dash format and then I'll specify markdown. And now we have our transcript analysis saved to transcript analysis dot md. We can see this file created here. If we click this, you can see we're now getting this great markdown summary. This is much easier to read, right? This is a great format. It's also a concrete file. So we can keep track of all of our generations. We can go ahead, run this again. We'll come back to the terminal, hit up and then let's generate our JSON version. Wonderful. Now we have our transcript analysis dot JSON. If we look at that, we have a wonderful JSON file breakdown that we can reuse across other applications. Our AICOINT and prompts ran really well. We did miss the context of our ARG parse file on the first go around. So you saw our AICOINT and assistants did not have visibility into this file, right? So we're just added that additional argument to the main. That's okay. We ran another prompt. We made sure that we had all the contacts we needed and then we use an information tense keyword prompt to move that content. So let's go ahead and backtrack and look at the prompts and break them down. So if I hit up a few times, get back to our prompt. Let's go ahead and move it to a new file. Now let's do some formatting. So I'm going to format here. I'll format here. We have two file create statements here. Great. So this is what this looks like when we format a little bit. Now let's go ahead and walk through this. We have one, two, three, four, five information dense keywords in this prompt and they're actually quite a few more will note in a moment. Let's start at the top. We said create output format dot p y. So even just in these two strings, we have a decent amount of information here, right? We want to create a new file and we're specifying this file by saying output format dot p y. Keep in mind if you remove dot p y, it's not clear if this is a variable, if this is a function, if this is a class, what is output format? Okay. But by adding dot p y, it's clear to our AI coding assistant and really the language model underneath it that this is a Python file. Now inside of that, we use colon to kind of denote the nested level here. It's important to note that this colon here doesn't need to be a colon, right? You could use a dash here. I recommend using colon because it's consistent and it's simple. Next, we have another create keyword and now we have def format as string. So now we're using that Python function keyword and now we're specifying what we want done. We want to create this format as string method and we're specifying the parameters. When we say transcript analysis, it knows by reference, we're talking about this class exactly. So we want to pass that class in and then we're also specifying the return type in this one line. Even if you take off the create keyword, there is a lot of information here, right? We're passing in our parameter and our AI Croner Assistant can infer, take this and turn it into a string. And if we look at that file, right, if we look at our output file, that's exactly what it did, right? It inferred that exactly exclusively based on our function definition. This is an ultra powerful pattern, especially when our context and function names are enough for the model to infer the content of the function itself. You can write tons of code by providing the right function definition. Hold on to this idea. We're then using the list syntax with these commas. Remember, we're communicating to LLMs and they of course know that a comma means we're separating items in a list that enables us to wrap the other pieces of our function keyword, right? So you can see here, we also want formatted JSON, formatted as markdown and we're dropping the dev keyword and we're also skipping the parameters, right? LLMs are great at pattern recognition. This is a pattern. Okay, so that's kind of one block of code changes and then we have another block down here, right? Update, main.py, update the main file, right? Two information tons keywords. Column, we're saying add. Notice how this is not create, right? This could very well be create and it would very likely work. But notice the detail of using an add keyword. Add means we're attaching to things that already exist. We already have CLI args. So add is a little more information rich here. I know that sounds really niche and really unnecessary, but as your context grows, as you're working with hundreds and hundreds of files, a little change like this can make a difference and trust me, I've seen it. It does make a difference. So add a CLI arg for file output format and then we're using the default keywords. It's a very common one. A big piece of great engineering is setting up great defaults. So we're saying default text comma, right? So we have this list pattern once again, save output to file with proper extension. And if we look at main, we can see that that is exactly what happened, right? We have our args output format getting checked and then we're also saving the file extension properly based on the output format. Now when we work through it, there's actually a lot of information we're sending to our AI coding assistant in this AI coding prompt. We're being clear and concise without going into the details of how to do it. Remember what greater than how the what is more important than the how, not completely, but much, much more than it has been. So even though we're not being verbose about how to implement each function, you might be thinking, isn't this some of the work we're supposed to be passing off to our AI coding assistants? Can't I just write something like this, right? Like add JSON, markdown and text CLI arg output formats, then update main. Couldn't you have just written something like this versus this, right? And you can see here, this is 128 characters. Here we have 66. The answer of course is yes. You very likely could have you, you may have gotten away with it, right? If you had all the right context setup and it may have worked, but notice I keep using these conditional words, it may have worked probably. Especially when you're starting, it's best to start out with these detailed low level prompts and slowly move to higher level prompts, right? Mid-level high level prompts with less explicit information in them. We'll discuss this idea more throughout this lesson and in future lessons. Look at how much information this high level prompt is missing, right? Add JSON, markdown and text where, right? Where are we adding these? Then update main, update what in main, right? After what? What do you mean by output formats? Are you just saying create a string? Are you saying create a file? Already returning, already printing? What's happening here? Do you see how much information is missing from this high level coding prompt? Versus our low level detailed coding prompt, right? Create output format.py. Okay, we're going to create a file. Create death format as string. Return a string. Pass in the transcript. Oh, okay. We're going to format this type as a string. Return it and then do JSON and then do markdown. Okay, I can see this is in list formats. You want me to create many of these dot dot dot. Okay, probably means we want to pass in transcript update main. Okay, so now we're creating and then we're updating main. I can see that this is after disk is generated, right? And then we're saying add CLI arg for output format. Default text and then we're saying save output. Default file with proper extension. Do you see how much more information is in the low level prompt? This is important. We're going to talk about this more. The general theme is as you're learning at coding, start with low level prompts and then slowly remove information. As you're progressing slowly start to remove things, right? Maybe you don't need the death keyword here, right? You can experiment with removing this, right? Maybe create is unnecessary here, right? Because we're already saying put it in the output format file. It doesn't exist. So maybe we're just creating it. Maybe you don't need to explicitly say update main. These are things and ideas you can play with. But when you're starting, when you're beginning your a coding journey, and when you want to progress and actually get things done, just write the extra characters, communicate clearly to your large language model. And most importantly, communicate clearly with yourself. Know exactly the output you want to see by creating the low level prompt. So let's go ahead and move on. We spent a lot of time digging into this prompt, dissecting it. Let's write a couple more prompts by building out our next features. And then let's move on to breaking down the prompt phrases. As you can see here, there are repeatable patterns embedded in our prompt here that you can reuse with Ader and every single a coding tool moving forward. So let's go ahead and get rid of this. And let's move on to our next feature. So let's go ahead and update our transcript analysis application to output a bar chart for our word frequencies. Instead of our pseudo hashtag bar chart, right? If we hop back to Ader, let's go ahead and drop all of our files from Ader's context window looking to that with slash drop. I want to show you two tricks. You can use to speed up your context manage. We've been adding files, but you can also specify entire directory. So if we do something like this, we say slash add source. And let's also add our pie project.tomalfile. And enter here, you can see every file underneath our source got added. So we have our knit, we have our parse constants data LM. That's everything that is not get ignored. That's really important inside of our directory. So that's a very powerful tool. If you want to add a bunch of context right away, let's use a new command available to you in Ader. This is effectively your chat conversation that you can have with Ader. If we go ahead and clear and type slash ask, you can now ask Ader any question you want to about your code base. So let's go ahead and just ask what libraries do we have for creating bar charts? Okay, and that's just in question format. So though nothing fancy here. No special prompt phrases or IDKs and use. I'm just asking a question, right? If we open this up a little bit, scroll up, you can see Ader with the slash ask command is just responding to us. And it's picked up on the fact that we have this matplotlib library in our pie project.tomalf. So we can use this library to create our bar chart and you can use the slash ask at any point in time when you're working with your A coding assistant to ask a question about the files in your context window. Nearly every A coding assistant today and in the future we'll have some type of chat conversation window, some type of conversational element where you can just effectively talk to your code base. This is a really important pattern and something I want to mention so let's you're aware of it. Whenever you're revisiting code bases, opening up new code bases, you can always just type slash ask what does this code base do, right? And really you can ask anything. You can see here it's giving us a nice summary of what the application does, transcript analysis, we're counting output, CLI, so on and so forth, right? So let's go ahead and create this bar chart. So I'll go ahead and drop and then I'll just add what we need to run this prompt. So it's going to be slash add. Let's bring back our project tome so that eight or no's we have access to matplotlib, all add main. And this should be all we need here. So we'll just use these files. I'll clear. And now let's go ahead and write our incis information dense keyword rich prompt create following that same pattern chart up you while colon death word count bar chart word count. Dict this is really important. I'm referencing a variable that exists in our main file, right? If we search word count, you can see that is a variable here colon. So inside of this show horizontal bar chart sort descending. Okay, after that, I'll type update main right. So now after we have that bar chart generated update main replace. Make sure I have my call in there replace word count print with word count bar chart. I'm explicitly saying replace our word count with the new function that we have created. Then I'll say move threshold logic after four word loop. Remember, we have this threshold logic that's happening inside of our print. We are replacing our word count print. You have to be careful and always aware of the changes your a coding assistant is going to make. So we're just saying move threshold logic after our four word loop. This prompt looks good. We're going to make one additional change it. We want to make sure that our threshold word count is actually used inside of our word count. And so all I'm going to do is back up a little bit and I'm going to use our threshold keyword to our advantage threshold word count. As the variable name is going to be passed in this in combination with our move threshold logic should give our a coding assistant everything it needs to solve this. So we'll go ahead and enter here. We'll hit yes. So we're going to create both these items. And let's go ahead and look. So you can see there that was a key change that we made there threshold word count. So that's getting passed in by variable name. And this is the power of let's go ahead and just revisit that prompt for just a moment here. So I'm just going to copy this and paste this. This is the power of using variable keywords. That's really, really important here. We passed this in as a variable keyword. We knew that we needed to move our threshold logic after the four word loop. So we use this variable to make sure that that content would be passed back in. Remember we're focusing on crafting the perfect a coding prompt. So that's how we got it there. So you can see our word count bar chart is getting created here. We didn't say how to do it. All we did was ask our a coding assistant to get it done for us by defining the function definition. Right. So we have word count bar chart passing the content and add a detail for what exactly we want to have done. So let's go and run this. Let's make sure that this works. Always show the proof. So I'll just type I'll use control R for back search and I'll just look for run. Okay. So we'll run this. Wonderful. This is really cool. Right. So now we have this nice bar chart that we can look at our word count frequencies through. And we can a lot more clearly see the counts here. Let's go ahead and close this. And you can see our application is still spinning a little bit. Now it's making that open AI call. So let's go ahead and make a couple tweaks here. Right. So let's go ahead and update our min threshold because if we look at our arque parse file, default three. So not super useful. And let's go ahead and run another prompt to move word count bar chart below our analysis just so that we get our analysis first. We don't want the application to stall in a weird way. Again, we'll fire off a really simple ad coding prompt for this and it will break down the id case and the prompt phrases inside of this a coding prompt. So go ahead and clear and then I'll run update. And if we look at our arque parse here, we can see what we have. Yeah. So I want to update this. So I want to say update and you know, always feel free to copy content right in. So I'm going to update main count threshold default 10. Let's bump up to 10. And I'll say move. So if we hop back to main here, I want to move this. So I'll just say move bar chart. And let's be really explicit right. We want to correct perfect prompts. So I'll copy this function move this below this. That's it. Fire it off. And so you know, with these keywords with this functionality, you can see that things are happening very precisely right. We're crafting perfect prompts. We're getting the exact result we're looking for without going into too much of the detail of how we're doing everything. So if we look at our parser, we don't have set defaults set the 10. I haven't seen this syntax. This is new. Ever once in a while, your egg coding system is just going to do something new that you like. They haven't seen. Let's just run it and see if it works. So we'll go ahead and rerun. We'll just look for the run and let's go ahead and update to mark down and let's keep this off. So now we're going to run our open AI transcript analysis call first and then create our bar chart. So that's what's happening right now. Perfect. So now we have this that threshold is working right. So now we're getting a nice clean list. You can also see we are not getting our sorted items. So let's go ahead and make that happen. So I'll just close this. So if we look back at this, our coding assistant did just completely miss this and we'll just do our same formatting here, right? You can see we did explicitly say sort descending spelled wrong. Let's go ahead and add this here. This is something that was just completely miss, right? Maybe it's because I spelled it wrong. This is something that an AI coding assistant should easily be able to fix. It didn't. That's reality. Things just don't work really quickly by validator code. We found that and we can now just come in update word count and we can see aider giving us autocomplete sort descending. Okay. So that's all we need. Our AI coding assistant will know that this is the function that we want to update, right? There's no way I can get this confused with anything else. We'll just hit that. And you can see in this file, it fixed that ran the zip and now we should be able to just go ahead and rerun this and see all of our counts sorted descending. Wonderful. So looking a lot cleaner, right? You can is file I so on and so forth. So let's go ahead and break down this prompt create chart. Def word count bar chart. We have a variable here. And then we're saying inside of this method, I want you to show horizontal bar chart. Next, we have another grouping of changes inside this file update may not be why replace word count print with our function. There is no way for the LM to get this confused. It either has to just blatantly hallucinate or it needs to get it right. And this is part of accurate AI coding. You need to create scenarios where there is no room for interpretation, right? If you want to graph perfect prompts, the information needs to be completely clear. We then say move threshold logic after for word loop. And this worked for the most part. We did miss our sort descending again. I missed the S there. So maybe we can say that I calls that hallucination. If you run this, you will likely not run into this issue here. It will probably have gotten that sort descending call for you. This is wonderful, right? We're so writing low level prompts. Let's add another layer to this and just make this pattern really discreet and really clear. And then we do something like this. What do you see here, right? You see a location phrase. Let's go ahead and bump this up a little bit. Right? You see a location. Then you see an action. Then you see a detail. Here we see a location. We see an action. And then we see a detail, right? And we can really actually bump this to its own line as well, right? Location, action, detail, action, detail. Okay. This is prompt phrasing, right? We are breaking our prompts down into individual pieces, locations, actions, details. It's important to note that a function, as you saw in our previous prompt, if we backtrack a little bit, hit up, right? We can see that our function operated as a location and a detail. There is no other place where word count bar chart exists in this code base, right? We can search this. And all you see is this function definition and then it getting imported and used. This is a really, really important idea for you to hold on to, right? If we hit up again, you can see that same pattern, right? So we're saying update, min count threshold. If we search min count threshold, where is that? It's here. It's our default argument. This is both a location and a detail, right? So we're saying update this location. In this case, it's a variable, right? So you see this as a variable. You see this as a function. And of course, we've been writing it mostly as a file. We have location, action, detail. So this is a great way to perhaps repeatable, consistent prompts. And all we're trying to do here with this pattern is consistently communicate to our large language model and our AI coding assistant, where and what, correct? Notice I didn't say how to create this bar chart. All I did was add the right context, pieprogist.tomel, right? If you open that up, you can see we have Matt Paul lib right there. We have four dependencies and our AI coding assistant can see everything in this file, right? And at the time of writing that prompt, we also had main. Okay, so it had all this information and it had the information we're giving it in our prompt. This is a really important pattern. You're going to see throughout this course, and it's a great, consistent way for you to think about you get an idea, you get a feature, you have requirements for brand new feature for your work, for your application. Now you have a repeatable structure to write it out in a prompt that's going to give you great results. Now the game is about how much time are you training off trying to hit the big three bullseye, right? Spending time gathering the right context, writing the right prompt. How much time do you spend setting up that intersection and then crafting a great intramation, dense keyword, prompt with a repeatable pattern like prompt phrasing, right? Let's just run that one more time. Action, action, detail. All right, so we're making a lot of great progress here. Let's round things out by making a few last changes. Let's close this. Let's just go ahead and do a full resale. Let's clear, let's drop. And what's the programming is setting up patterns and then using those patterns. The mirror keyword lets you tap into that element of engineering with a single word, right? This is why it's an information dense keyword. We're going to run our next prompt with the powerful mirror keyword. As an example, let's say we want to add another output format, right? Let's say we want to add YAML. So I'll go ahead, I'll add main, I'll add our format and I'll add our pie project so that we can see pie YAML library. So we have these items slash tokens. We're running a prompt at under scent for the input tokens. We also need to add one more file. We need our art parts because this also has our output format list. So we'll just say slash add, art parts, okay? And then let's go ahead and write this prompt. So all we have to say here is update main.py, output format.py and art parts add format as YAML and I'll just say mirror format as JSON, okay? We'll kick that off. So we're saying three files, we have three locations and then we have a function name and then a detail. So you can see that's all getting added. We have a three file, multi-file edit. Let's go ahead and kick this off with uvrunmaintranscript.txt, output format, YAML. Wonderful. So we have our bar chart here. If we close this, we're going to see our YAML file, right? We can go ahead and take a look at this, open this up. And in YAML format, we now have our quick summary, bullet highlights, sentiment and our keywords. And if we quickly review this prompt, you can see the exact same patterns, right? And you're starting to understand everything that's going on here, right? We're saying update and then we're using a list here. There's a combination of some patterns you've been working with. We have a location, we have an action, and then we have a detail. We're using the update, add, and mirror keywords to get the job done. By crafting low-level prompts before we move to high-level prompts, and by using information dense keywords and prompt phrases, you can consistently build high-quality, accurate AI coding prompts. As models progress, and this is the key, we're setting ourselves up to win as models progress, right? These large English models are going to continue to improve. So we're building up our skills we need to control and guide our AI coding assistance to produce the results we're trying to get. Play with these ideas, test them out, find your own IDKs, and reuse the ones you've seen here in this lesson to get a lot done in a little bit of time with just a tad more upfront investment in crafting a great prompt. Congratulations, if you made it this far and you're understanding the concepts, you are now an intermediate AI coder. Congratulations. Take what you've learned here and use it on real code bases. Don't wait, hop into code bases. Focus on using the big three bulls eye. Focus on using IDKs, right? Use these information dense keywords. Create update, delete, move, mirror. There's a whole bag of them. It's time to put what you're learning into practice. Get that experience. Deploy your AI coding assistant and get work done. In upcoming lessons, we're going to break down common pitfalls and solution to these pit falls so that you can continue progressing. We're going to generate a ton of code with the strong week model pattern using reasoning models as orchestrators. Take a world's air break, feel free to browse all the content and guides in your loot box. That will help you memorize and understand everything we've discussed in these lessons in real world engineering scenarios. We've covered high level versus low level information dense keywords and prompt phrases. Put these pieces together so that you can consistently craft high quality, accurate, AI coding prompts. Great job so far. I'll see you in the next one where things really take off.